name: Deploy to VPS (gated + fast + safe)

on:
  workflow_run:
    workflows: ["Build (Next + Strapi)"]
    types: [completed]
  workflow_dispatch:

concurrency:
  group: deploy-main
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 70
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main')
    env:
      DEPLOY_SHA: ${{ github.event.workflow_run.head_sha || github.sha }}

    steps:
      - name: Debug trigger
        run: |
          echo "event=${{ github.event_name }}"
          echo "conclusion=${{ github.event.workflow_run.conclusion }}"
          echo "head_branch=${{ github.event.workflow_run.head_branch }}"
          echo "head_sha=${{ github.event.workflow_run.head_sha }}"
          echo "deploy_sha=${{ env.DEPLOY_SHA }}"

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          DEPLOY_SHA: ${{ env.DEPLOY_SHA }}
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_KEY }}
          port: ${{ secrets.VPS_PORT }}
          envs: DEPLOY_SHA
          script_stop: true
          command_timeout: 60m
          script: |
            # --- bash guard ---
            if [ -z "${BASH_VERSION:-}" ]; then
              echo "ERROR: This script must run in bash. Current shell is not bash."
              exit 1
            fi

            set -Eeuo pipefail

            STAGE="init"
            log(){ printf '[%s] [%s] %s\n' "$(date -Is)" "$STAGE" "$*"; }
            die(){ log "❌ ERROR: $*"; exit 1; }

            on_err(){
              local ec=$?
              local line=${BASH_LINENO[0]:-?}
              log "❌ FAIL (exit=$ec) at line $line: ${BASH_COMMAND}"
              exit "$ec"
            }
            trap on_err ERR

            # --- capture runner: ha elhasal valami, kiírjuk a konkrét hibát ---
            run_capture() {
              local name="$1"; shift
              local f="/tmp/deploy_${DEPLOY_SHA}_${name}.log"

              log "RUN: $name"
              set +e
              "$@" >"$f" 2>&1
              local rc=$?
              set -e

              if [ "$rc" -ne 0 ]; then
                log "❌ $name failed rc=$rc — last 220 lines:"
                tail -n 220 "$f" || true

                log "npm debug log tail (if exists):"
                local npm_log
                npm_log="$(ls -t /root/.npm/_logs/* 2>/dev/null | head -n 1 || true)"
                [ -n "$npm_log" ] && tail -n 220 "$npm_log" || true

                die "$name failed"
              fi

              log "✅ $name OK"
            }

            REPO="/var/www/health-template"
            DOMAIN="https://theplacestudio.hu"
            LOCK_FILE="/var/lock/health-template-deploy.lock"

            log "=== Deploy SHA === $DEPLOY_SHA"
            [ -n "${DEPLOY_SHA:-}" ] || die "DEPLOY_SHA is empty"

            STAGE="lock"
            command -v flock >/dev/null 2>&1 || die "flock missing (install util-linux)"
            exec 9>"$LOCK_FILE"
            if ! flock -n 9; then
              log "Another deploy is running -> exit 0"
              exit 0
            fi

            STAGE="prechecks"
            command -v pm2   >/dev/null 2>&1 || die "pm2 missing"
            command -v git   >/dev/null 2>&1 || die "git missing"
            command -v curl  >/dev/null 2>&1 || die "curl missing"
            command -v node  >/dev/null 2>&1 || die "node missing"
            command -v npm   >/dev/null 2>&1 || die "npm missing"
            command -v rsync >/dev/null 2>&1 || die "rsync missing (required for safe swap_dir)"

            cd "$REPO" || die "Cannot cd $REPO"
            git rev-parse --is-inside-work-tree >/dev/null 2>&1 || die "Not a git repo: $REPO"

            # safety: ne töröljünk szerver oldali kézi módosítást
            if ! git diff --quiet || ! git diff --cached --quiet; then
              die "Working tree is dirty (uncommitted changes). Abort."
            fi

            STAGE="fetch"
            OLD_SHA="$(git rev-parse HEAD 2>/dev/null || true)"
            log "OLD_SHA=$OLD_SHA"
            git fetch --all --prune
            git cat-file -e "$DEPLOY_SHA^{commit}" 2>/dev/null || die "DEPLOY_SHA not found in repo objects"

            if [ -n "$OLD_SHA" ] && [ "$OLD_SHA" = "$DEPLOY_SHA" ]; then
              log "No change (OLD_SHA == DEPLOY_SHA). Exiting."
              exit 0
            fi

            STAGE="detect-changes"
            NEED_NEXT=1
            NEED_STRAPI=1
            LOCK_NEXT_CHANGED=1
            LOCK_STRAPI_CHANGED=1

            if [ -n "$OLD_SHA" ]; then
              CHANGED="$(git diff --name-only "$OLD_SHA" "$DEPLOY_SHA" || true)"
              log "Changed files (head 200):"
              printf "%s\n" "$CHANGED" | head -n 200 || true

              NEED_NEXT=0
              NEED_STRAPI=0
              printf "%s\n" "$CHANGED" | grep -qE '^next/'  && NEED_NEXT=1 || true
              printf "%s\n" "$CHANGED" | grep -qE '^strapi/' && NEED_STRAPI=1 || true

              LOCK_NEXT_CHANGED=0
              LOCK_STRAPI_CHANGED=0
              git diff --name-only "$OLD_SHA" "$DEPLOY_SHA" -- next/package-lock.json   | grep -q . && LOCK_NEXT_CHANGED=1 || true
              git diff --name-only "$OLD_SHA" "$DEPLOY_SHA" -- strapi/package-lock.json | grep -q . && LOCK_STRAPI_CHANGED=1 || true
            fi

            log "NEED_NEXT=$NEED_NEXT NEED_STRAPI=$NEED_STRAPI"
            log "LOCK_NEXT_CHANGED=$LOCK_NEXT_CHANGED LOCK_STRAPI_CHANGED=$LOCK_STRAPI_CHANGED"

            if [ "$NEED_NEXT" -eq 0 ] && [ "$NEED_STRAPI" -eq 0 ]; then
              log "No next/strapi changes -> skipping deploy."
              exit 0
            fi

            STAGE="backup"
            (
              set +e
              B="/root/backups/fullsite-latest"
              umask 077
              mkdir -p "$B" "$B/pm2"

              rm -rf "$B/pm2" "$B/uploads" 2>/dev/null
              rm -f "$B/server_state.txt" "$B/strapi_data.db" "$B/nginx_config.tgz" 2>/dev/null
              mkdir -p "$B/pm2"

              {
                echo "DATE: $(date -Is)"
                echo "HOST: $(hostname)"
                echo
                echo "PM2 STATUS:"
                pm2 status || true
                echo
                echo "GIT STATUS:"
                git status -sb || true
                echo
                echo "LAST COMMITS:"
                git log --oneline -n 20 || true
              } > "$B/server_state.txt" || true

              DB_REAL="$(readlink -f strapi/.tmp/data.db 2>/dev/null || true)"
              if [ -n "${DB_REAL}" ] && [ -f "${DB_REAL}" ]; then
                if command -v sqlite3 >/dev/null 2>&1; then
                  sqlite3 "${DB_REAL}" ".backup '${B}/strapi_data.db'" || true
                fi
                [ -f "${B}/strapi_data.db" ] || cp -a "${DB_REAL}" "${B}/strapi_data.db" || true
              fi

              if [ "$NEED_STRAPI" -eq 1 ] && [ -d "strapi/public/uploads" ]; then
                mkdir -p "$B/uploads"
                rsync -a --delete "strapi/public/uploads/" "$B/uploads/" || true
              fi

              tar -czf "$B/nginx_config.tgz" \
                /etc/nginx/nginx.conf \
                /etc/nginx/sites-available \
                /etc/nginx/sites-enabled 2>/dev/null || true

              cp -a /root/.pm2/dump.pm2 "$B/pm2/" 2>/dev/null || true
              pm2 jlist > "$B/pm2/pm2_jlist.json" 2>/dev/null || true
              echo "Backup size: $(du -sh "$B" 2>/dev/null || echo n/a)"
              exit 0
            ) || true

            STAGE="staging-build"
            DEPLOY_ROOT="$REPO/.deploy"
            BUILD_DIR="$DEPLOY_ROOT/build-$DEPLOY_SHA"
            mkdir -p "$DEPLOY_ROOT"
            rm -rf "$BUILD_DIR" 2>/dev/null || true

            git worktree add --detach "$BUILD_DIR" "$DEPLOY_SHA" >/dev/null

            cleanup_worktree(){
              ( cd "$REPO" && git worktree remove --force "$BUILD_DIR" >/dev/null 2>&1 ) || true
              ( cd "$REPO" && git worktree prune >/dev/null 2>&1 ) || true
            }
            # IMPORTANT: őrizze az eredeti exit code-ot
            trap 'rc=$?; cleanup_worktree; exit $rc' EXIT

            # env copy
            if [ -f "$REPO/next/.env.production.local" ]; then
              cp -a "$REPO/next/.env.production.local" "$BUILD_DIR/next/.env.production.local"
            fi
            if [ -f "$REPO/strapi/.env" ]; then
              cp -a "$REPO/strapi/.env" "$BUILD_DIR/strapi/.env" || true
            fi

            if [ "$NEED_NEXT" -eq 1 ]; then
              STAGE="build-next"
              run_capture "next_npm_ci" bash -lc "cd '$BUILD_DIR/next' && npm ci --no-audit --no-fund"
              run_capture "next_build"  bash -lc "cd '$BUILD_DIR/next' && npm run build"
            else
              log "Skip next build"
            fi

            if [ "$NEED_STRAPI" -eq 1 ]; then
              STAGE="build-strapi"
              run_capture "strapi_npm_ci" bash -lc "cd '$BUILD_DIR/strapi' && npm ci --no-audit --no-fund"
              run_capture "strapi_build"  bash -lc "cd '$BUILD_DIR/strapi' && npm run build"
            else
              log "Skip strapi build"
            fi

            STAGE="apply-live-code"
            cd "$REPO"
            git reset --hard "$DEPLOY_SHA"
            log "LIVE HEAD NOW: $(git rev-parse HEAD)"
            log "LIVE COMMIT: $(git show -s --oneline HEAD)"

            install_live_if_needed(){
              local app="$1"
              local lockfile="$REPO/$app/package-lock.json"
              local hash_dir="$REPO/.ci"
              local hash_file="$hash_dir/${app}_lock_hash"
              mkdir -p "$hash_dir"

              if [ ! -f "$lockfile" ]; then
                log "WARN: $app/package-lock.json missing -> npm ci"
                run_capture "${app}_live_npm_ci" bash -lc "cd '$REPO/$app' && npm ci --no-audit --no-fund"
                return 0
              fi

              local cur_hash old_hash=""
              cur_hash="$(sha256sum "$lockfile" | awk '{print $1}')"
              [ -f "$hash_file" ] && old_hash="$(cat "$hash_file" 2>/dev/null || true)"

              if [ -d "$REPO/$app/node_modules" ] && [ -n "$old_hash" ] && [ "$cur_hash" = "$old_hash" ]; then
                log "✅ $app deps unchanged -> skip npm ci (live)"
              else
                log "→ $app deps changed/missing -> npm ci (live)"
                run_capture "${app}_live_npm_ci" bash -lc "cd '$REPO/$app' && npm ci --no-audit --no-fund"
                echo "$cur_hash" > "$hash_file"
              fi
            }

            if [ "$NEED_NEXT" -eq 1 ]; then install_live_if_needed "next"; fi
            if [ "$NEED_STRAPI" -eq 1 ]; then install_live_if_needed "strapi"; fi

            swap_dir(){
              local target_dir="$1"
              local source_dir="$2"
              local new_dir="${target_dir}.new"
              local prev_dir="${target_dir}.prev"
              rm -rf "$new_dir" "$prev_dir" 2>/dev/null || true
              mkdir -p "$new_dir"

              rsync -a --delete "$source_dir/" "$new_dir/"

              if [ -d "$target_dir" ]; then
                mv "$target_dir" "$prev_dir"
              fi
              mv "$new_dir" "$target_dir"
            }

            if [ "$NEED_NEXT" -eq 1 ]; then
              STAGE="swap-next"
              swap_dir "$REPO/next/.next" "$BUILD_DIR/next/.next"
            fi

            if [ "$NEED_STRAPI" -eq 1 ]; then
              STAGE="swap-strapi"
              swap_dir "$REPO/strapi/dist" "$BUILD_DIR/strapi/dist"
            fi

            STAGE="restart"
            if [ "$NEED_NEXT" -eq 1 ]; then pm2 restart next --update-env; fi
            if [ "$NEED_STRAPI" -eq 1 ]; then pm2 restart strapi --update-env; fi
            pm2 save || true

            STAGE="smoke"
            check_url(){
              local url="$1"
              local name="$2"
              local tries="${3:-15}"
              local ok=0
              for i in $(seq 1 "$tries"); do
                code="$(curl -sS -o /dev/null -w "%{http_code}" -L --connect-timeout 5 --max-time 15 "$url" || echo 000)"
                log "$name code=$code (try $i)"
                if [ "$code" -ge 200 ] && [ "$code" -lt 400 ]; then ok=1; break; fi
                sleep 2
              done
              [ "$ok" -eq 1 ] || return 1
              return 0
            }

            rollback(){
              STAGE="rollback"
              log "=== ROLLBACK to OLD_SHA=$OLD_SHA ==="
              [ -n "${OLD_SHA:-}" ] || { log "No OLD_SHA -> cannot rollback"; return 1; }

              if [ "$NEED_NEXT" -eq 1 ] && [ -d "$REPO/next/.next.prev" ]; then
                rm -rf "$REPO/next/.next" 2>/dev/null || true
                mv "$REPO/next/.next.prev" "$REPO/next/.next" || true
              fi
              if [ "$NEED_STRAPI" -eq 1 ] && [ -d "$REPO/strapi/dist.prev" ]; then
                rm -rf "$REPO/strapi/dist" 2>/dev/null || true
                mv "$REPO/strapi/dist.prev" "$REPO/strapi/dist" || true
              fi

              git reset --hard "$OLD_SHA" || true
              if [ "$NEED_NEXT" -eq 1 ]; then pm2 restart next --update-env || true; fi
              if [ "$NEED_STRAPI" -eq 1 ]; then pm2 restart strapi --update-env || true; fi
              pm2 save || true
              log "ROLLBACK DONE ✅"
            }

            check_url "$DOMAIN/hu" "HOME" 10 || { log "SMOKE FAIL: home"; rollback || true; exit 1; }
            check_url "$DOMAIN/api/global" "API(global)" 20 || { log "SMOKE FAIL: api/global"; rollback || true; exit 1; }

            log "DEPLOY DONE ✅"
